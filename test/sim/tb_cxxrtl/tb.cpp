#include <iostream>
#include <fstream>
#include <cstdint>
#include <cstring>
#include <string>
#include <stdio.h>

#include "tb.h"
#include "tb_cli.h"
#include "tb_jtag.h"

// Device-under-test model generated by CXXRTL:
#include "dut.cpp"
#include <cxxrtl/cxxrtl_vcd.h>
#ifdef CXXRTL_DEBUG_AGENT
#include <cxxrtl/cxxrtl_server.h>
using namespace cxxrtl::time_literals;
#endif

#ifdef CXXRTL_DEBUG_AGENT
#define STEP() agent.step();
#else
#define STEP() top.step();
#endif

#ifndef TB_DEBUG
#define TB_DEBUG 0
#endif

#ifndef TB_DEBUG_CYCLES
#define TB_DEBUG_CYCLES 80
#endif

#if TB_DEBUG
#define TB_DBG(cycle, ...) do { if ((cycle) < TB_DEBUG_CYCLES) fprintf(logfile, __VA_ARGS__); } while (0)
#else
#define TB_DBG(cycle, ...) do { (void)(cycle); } while (0)
#endif

static constexpr uint32_t TB_BOOT_PC = 0x80000040u;

class tb_cxxrtl_top: public tb_top {
	cxxrtl_design::p_tb top;
	cxxrtl::vcd_writer vcd;
	std::ofstream waves_fd;

	int64_t cycle = 0;

#ifdef CXXRTL_DEBUG_AGENT
	cxxrtl::agent<cxxrtl_design::p_tb> agent(cxxrtl::spool("spool.bin"), top);
#endif

public:
	tb_cxxrtl_top(const tb_cli_args &args);
	void step(const tb_cli_args &args, mem_io_state &memio) override;
	void finish(const tb_cli_args &args);

	void set_trst_n(bool trst_n)     override {top.p_trst__n.set<bool>(trst_n);}
	void set_tck(bool tck)           override {top.p_tck.set<bool>(tck);}
	void set_tdi(bool tdi)           override {top.p_tdi.set<bool>(tdi);}
	void set_tms(bool tms)           override {top.p_tms.set<bool>(tms);}
	bool get_tdo()                   override {return top.p_tdo.get<bool>();}

	void set_irq(uint32_t mask)      override {top.p_irq.set<bool>(mask != 0);}
	void set_soft_irq(uint8_t mask)  override {top.p_soft__irq.set<uint32_t>(mask & 0x3u);}
	void set_timer_irq(uint8_t mask) override {top.p_timer__irq.set<uint32_t>(mask & 0x3u);}
};
tb_cxxrtl_top::tb_cxxrtl_top(const tb_cli_args &args): tb_top {args} {
	if (args.dump_waves) {
		waves_fd.open(args.waves_path);
		cxxrtl::debug_items all_debug_items;
		cxxrtl::debug_scopes all_debug_scopes;
		top.debug_info(&all_debug_items, &all_debug_scopes, "");
		vcd.timescale(1, "us");
		vcd.add(all_debug_items);
	}
#ifdef CXXRTL_DEBUG_AGENT
	if (args.run_agent) {
		std::cerr << "Waiting for debugger on " << agent.start_debugging() << std::endl;
	}
#endif

	// Initialize AXI bus to idle
	top.p_i__axi__ar__ready.set<bool>(true);
	top.p_i__axi__r__valid.set<bool>(false);
	top.p_i__axi__r__data.set<uint32_t>(0);
	top.p_i__axi__r__resp.set<uint32_t>(0);
	
	top.p_d__axi__aw__ready.set<bool>(true);
	top.p_d__axi__w__ready.set<bool>(false);
	top.p_d__axi__b__valid.set<bool>(false);
	top.p_d__axi__b__resp.set<uint32_t>(0);
	top.p_d__axi__ar__ready.set<bool>(true);
	top.p_d__axi__r__valid.set<bool>(false);
	top.p_d__axi__r__data.set<uint32_t>(0);
	top.p_d__axi__r__resp.set<uint32_t>(0);

	top.p_irq.set<bool>(false);
	top.p_soft__irq.set<uint32_t>(0);
	top.p_timer__irq.set<uint32_t>(0);

	// Reset + initial clock pulse
	top.p_rst__n.set<bool>(false);
	STEP();
	top.p_clk.set<bool>(true);
	top.p_tck.set<bool>(true);
	STEP();
	top.p_clk.set<bool>(false);
	top.p_tck.set<bool>(false);
	top.p_trst__n.set<bool>(true);
	top.p_rst__n.set<bool>(true);
	top.p_cpu_2e_Iptr.set<uint32_t>(TB_BOOT_PC);
	top.p_cpu_2e_instrMemory__PcReg.set<uint32_t>(TB_BOOT_PC);
	STEP();
	STEP(); // workaround for github.com/YosysHQ/yosys/issues/2780
}

void tb_cxxrtl_top::step(const tb_cli_args &args, mem_io_state &memio) {
	top.p_clk.set<bool>(false);
	STEP();
	if (args.dump_waves)
		vcd.sample(cycle * 2);
#ifdef CXXRTL_DEBUG_AGENT
	agent.advance(1_us);
#endif
	
	// Handle instruction fetch AXI transactions
	if (top.p_i__axi__ar__valid.get<bool>() && top.p_i__axi__ar__ready.get<bool>()) {
		bus_request req;
		req.addr = top.p_i__axi__ar__addr.get<uint32_t>();
		TB_DBG(cycle, "[dbg] i_ar=%08x\n", req.addr);
		req.size = SIZE_WORD;
		req.write = false;
		req.excl = false;
		bus_response resp = mem_callback_i(*this, memio, req);
		// Set response for next cycle
		top.p_i__axi__r__valid.set<bool>(true);
		top.p_i__axi__r__data.set<uint32_t>(resp.rdata);
		top.p_i__axi__r__resp.set<uint32_t>(resp.err ? 2u : 0u); // SLVERR/OKAY
		TB_DBG(cycle, "[dbg] i_r data=%08x resp=%u\n", resp.rdata, resp.err ? 2u : 0u);
	} else if (top.p_i__axi__r__valid.get<bool>() && top.p_i__axi__r__ready.get<bool>()) {
		top.p_i__axi__r__valid.set<bool>(false);
	}
	
	// Handle data read AXI transactions
	static bool d_r_pending_valid = false;
	static uint32_t d_r_pending_data = 0;
	static uint32_t d_r_pending_resp = 0;

	bool d_r_was_valid = top.p_d__axi__r__valid.get<bool>();
	bool d_r_was_ready = top.p_d__axi__r__ready.get<bool>();
	bool d_r_busy = d_r_pending_valid || d_r_was_valid;
	top.p_d__axi__ar__ready.set<bool>(!d_r_busy);

	if (d_r_was_valid && d_r_was_ready) {
		top.p_d__axi__r__valid.set<bool>(false);
	}

	if (!d_r_was_valid && d_r_pending_valid) {
		top.p_d__axi__r__valid.set<bool>(true);
		top.p_d__axi__r__data.set<uint32_t>(d_r_pending_data);
		top.p_d__axi__r__resp.set<uint32_t>(d_r_pending_resp);
		d_r_pending_valid = false;
	}

	if (top.p_d__axi__ar__valid.get<bool>() && top.p_d__axi__ar__ready.get<bool>()) {
		bus_request req;
		req.addr = top.p_d__axi__ar__addr.get<uint32_t>();
		TB_DBG(cycle, "[dbg] ar=%08x\n", req.addr);
		req.size = SIZE_WORD;
		req.write = false;
		req.excl = false;
		bus_response resp = mem_callback_d(*this, memio, req);
		// Queue response to be returned one cycle later
		d_r_pending_valid = true;
		d_r_pending_data = resp.rdata;
		d_r_pending_resp = resp.err ? 2u : 0u; // SLVERR/OKAY
		TB_DBG(cycle, "[dbg] r data=%08x resp=%u\n", resp.rdata, resp.err ? 2u : 0u);
	}

	

	// Handle data write AXI transactions
	static bool aw_pending = false;
	static uint32_t aw_addr = 0;
	static bool w_pending = false;
	static uint32_t w_data = 0;
	static uint32_t w_strb = 0;
	
	if (top.p_d__axi__aw__valid.get<bool>() && top.p_d__axi__aw__ready.get<bool>()) {
		aw_pending = true;
		aw_addr = top.p_d__axi__aw__addr.get<uint32_t>();
		top.p_d__axi__w__ready.set<bool>(true);
		TB_DBG(cycle, "[dbg] aw=%08x\n", aw_addr);
	}
	
	if (top.p_d__axi__w__valid.get<bool>() && top.p_d__axi__w__ready.get<bool>()) {
		w_pending = true;
		w_data = top.p_d__axi__w__data.get<uint32_t>();
		w_strb = top.p_d__axi__w__strb.get<uint32_t>();
		TB_DBG(cycle, "[dbg] w data=%08x strb=%x\n", w_data, w_strb);
	}
	
	if (aw_pending && w_pending) {
		bus_response merged_resp;
		if (w_strb == 0x1u || w_strb == 0x2u || w_strb == 0x4u || w_strb == 0x8u) {
			int byte = (w_strb == 0x1u) ? 0 : (w_strb == 0x2u) ? 1 : (w_strb == 0x4u) ? 2 : 3;
			bus_request req;
			req.addr = aw_addr + (uint32_t)byte;
			req.size = SIZE_BYTE;
			req.write = true;
			req.excl = false;
			req.wdata = (w_data >> (8 * byte)) & 0xffu;
			bus_response resp = mem_callback_d(*this, memio, req);
			merged_resp.err = resp.err;
		} else if (w_strb == 0x3u || w_strb == 0xCu) {
			int half = (w_strb == 0x3u) ? 0 : 2;
			bus_request req;
			req.addr = aw_addr + (uint32_t)half;
			req.size = SIZE_HWORD;
			req.write = true;
			req.excl = false;
			req.wdata = (w_data >> (8 * half)) & 0xffffu;
			bus_response resp = mem_callback_d(*this, memio, req);
			merged_resp.err = resp.err;
		} else if (w_strb == 0xFu) {
			bus_request req;
			req.addr = aw_addr;
			req.size = SIZE_WORD;
			req.write = true;
			req.excl = false;
			req.wdata = w_data;
			bus_response resp = mem_callback_d(*this, memio, req);
			merged_resp.err = resp.err;
		} else {
			TB_DBG(cycle, "[dbg] invalid w_strb=%x aw=%08x w=%08x\n", w_strb, aw_addr, w_data);
			merged_resp.err = true;
		}
		top.p_d__axi__b__valid.set<bool>(true);
		top.p_d__axi__b__resp.set<uint32_t>(merged_resp.err ? 2u : 0u); // SLVERR/OKAY
		TB_DBG(cycle, "[dbg] b resp=%u\n", merged_resp.err ? 2u : 0u);
		aw_pending = false;
		w_pending = false;
		top.p_d__axi__w__ready.set<bool>(false);
	} else if (top.p_d__axi__b__valid.get<bool>() && top.p_d__axi__b__ready.get<bool>()) {
		top.p_d__axi__b__valid.set<bool>(false);
	}
	
	top.p_clk.set<bool>(true);
	STEP();
	STEP(); // workaround for github.com/YosysHQ/yosys/issues/2780
	if (args.dump_waves)
		vcd.sample(cycle * 2 + 1);

	++cycle;
}

void tb_cxxrtl_top::finish(const tb_cli_args &args) {
	if (args.dump_waves) {
		waves_fd << vcd.buffer;
		vcd.buffer.clear();
		waves_fd.close();
	}
}

int main(int argc, char **argv) {
	tb_cli_args args;
	tb_parse_args(argc, argv, args);

	tb_jtag_state jtag(args);
	mem_io_state memio(args);
	if (args.load_bin && TB_BOOT_PC >= MEM_BASE && TB_BOOT_PC < MEM_BASE + MEM_SIZE) {
		uint32_t load_offset = TB_BOOT_PC - MEM_BASE;
		memmove(memio.mem + load_offset, memio.mem, MEM_SIZE - load_offset);
		memset(memio.mem, 0, load_offset);
	}
	tb_cxxrtl_top tb(args);

	bool timed_out = false;
	for (int64_t cycle = 0; cycle < args.max_cycles || args.max_cycles == 0; ++cycle) {
		bool jtag_exit_cmd = jtag.step(tb);
		memio.step(tb);
		tb.step(args, memio);

		if (memio.exit_req) {
			fprintf(tb.logfile, "CPU requested halt. Exit code %d\n", memio.exit_code);
			fprintf(tb.logfile, "Ran for " I64_FMT " cycles\n", cycle + 1);
			break;
		}
		if (cycle + 1 == args.max_cycles) {
			fprintf(tb.logfile, "Max cycles reached\n");
			timed_out = true;
		}
		if (jtag_exit_cmd)
			break;
	}

	jtag.close();
	tb.finish(args);

	for (auto r : args.dump_ranges) {
		fprintf(tb.logfile, "Dumping memory from %08x to %08x:\n", r.first, r.second);
		for (int i = 0; i < r.second - r.first; ++i)
			fprintf(tb.logfile, "%02x%c", memio.mem[r.first + i - MEM_BASE], i % 16 == 15 ? '\n' : ' ');
		fprintf(tb.logfile, "\n");
	}

	if (args.sig_path != "") {
		FILE *sigfile = fopen(args.sig_path.c_str(), "wb");
		for (auto r : args.dump_ranges) {
			for (uint32_t i = 0; i < r.second - r.first; i += 4) {
				fprintf(
					sigfile,
					"%02x%02x%02x%02x\n",
					memio.mem[r.first + i + 3 - MEM_BASE],
					memio.mem[r.first + i + 2 - MEM_BASE],
					memio.mem[r.first + i + 1 - MEM_BASE],
					memio.mem[r.first + i + 0 - MEM_BASE]
				);
			}
		}
		fclose(sigfile);
	}

	if (args.propagate_return_code && timed_out) {
		return -1;
	} else if (args.propagate_return_code && memio.exit_req) {
		return memio.exit_code;
	} else {
		return 0;
	}
}
